This CS-230 course involves the itterative investigation of and development of a fictitious software project based on the "Draw-It or Lose-it" game developed by the fictitious customer (The Gaming Room).  The project is viewed from the perspective of a consulting company, with the application being developed by a junior software engineer.

The software to be developed is intended to take an existing JAVA application and convert it to become an online application.  The customer initially does not mandate any specific architectures for use.  The application to be developed is eventually intended to be compatible across multiple client operating systems such as IOS, android, etc.

The code utilized in the course is exclusively JAVA, with guidance for using the Eclipse IDE toolset for development.

In the initial phases, an understanding of the possible design architectures are explored (mostly in readings), with a final selection of a singleton pattern being selected and then implemented thru mostly completed code that needed to have some tweaks made to ensure the architecture is implemented accordingly.

Once the singleton pattern is implemented, further exploration is continued with the introduction of the REST api and security including using DropWizard methods are then layered on, again thru lead exercises that are extrapolated from the literature guidance.

Across the entire term is introduced the idea and execution of a project software design architecture document that explores the gathering of customer requirements, summarizing the expected deliverables, documenting research and evaluations for the research findings, and finally providing the final recommendations to be reviewed and accepted prior to project acceptance and execution.

This Project Software Design document serves as a nice interface document with both technical and non-technical audiences to review the current state of technology, consolidate the customers requirements, which may evolve as the project chartering proceeds, consolidates the decisions as well as the open questions remaining for key decisions, and finally summarizes the recommendations the technical team has made to ensure awareness and buy-off occurs.

Within the context of the example project, many areas were readily completed with available documentation from the customer, as well as fairly straightforward reference articles from online sources.  One key challenge that occurs, is when a subject is not well understood by the technical team, REST API in this instance, can lead to challenges translating the requirements into actionable content that is concisely presented while also being technically accurate.

When summarizing the customers requirements, all unnecessary extra wording and formatting should be removed, and keep only the key actionable details in the form of a well formatted list.  This will then translate into a checklist for the developers and quality checking activities to ensure all requirements are easily understood and properly executed without the need for detailed interpretations.

As demonstrated in the early portion of the course, utilizing a software diagram showing how data flows thru the project is a crucial element to ensure data only ends up where it is needed, as well as following a predictable workflow allows for more efficient code, as well as giving a high level view for analysis without the need to read thru potentially massive amounts of code to understand the overall architecture.

For this particular application, the use of the software diagram was particularly useful and is a great method to communicate succinctly the data flow which often can be very confusing when inheriting code that someone else has written and you are expected to maintain.  This also helps to ensure the user's needs are met thru high level reviews of the overall architecture, data collected and transacted, and can lead to faster modifications before the code is ever written.
